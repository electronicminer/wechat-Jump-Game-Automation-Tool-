
自动跳跃脚本实现原理
一、鼠标标记位置原理
在脚本运行过程中，用户可以通过按键 1 和 2 来标记屏幕上的两个位置。程序会使用 pyautogui.position() 获取鼠标当前的坐标，并将这些坐标存储为全局变量 x1, y1 和 x2, y2。这两个位置主要用于定义后续截图的区域，确保图片获取的范围与游戏窗口对应。
该方法的主要目的是让用户能够根据实际游戏窗口的位置和大小灵活调整截图区域，从而提高角色和砖块检测的准确性。
二、角色检测原理
角色检测主要依赖于图像处理库 OpenCV 的模板匹配功能。以下是具体步骤：
截图获取：使用 pyautogui.screenshot 获取游戏窗口的截图，并通过 cv2.cvtColor 将截图转换为 BGR 格式。
模板匹配：使用 cv2.matchTemplate 将截取的屏幕图像与预先准备的模板图片（target.png）进行匹配。模板匹配通过计算输入模板与目标图像的相关性来识别游戏角色的位置，返回值为一个相似度矩阵。
位置定位：通过 cv2.minMaxLoc 函数找到相似度矩阵中的最大值位置，该位置即为角色在游戏截图中的坐标。此外，函数还会返回角色的宽度和高度，用于后续计算角色的中心位置。
角色检测原理如图所示：
https://example.com/role_detection.png
三、砖块检测原理
砖块检测采用了边缘检测技术，具体步骤如下：
截图处理：同样是通过 pyautogui.screenshot 获取游戏窗口的截图，但由于砖块通常位于游戏窗口的上方，因此会对截图区域进行一定的裁剪（region=(x1, y1, x2 - x1, y2 - y1 - 600)）。
图像预处理：
高斯模糊：使用 cv2.GaussianBlur 对截图进行高斯模糊处理，以减少图像噪声，提高边缘检测的准确性。
Canny 边缘检测：使用 cv2.Canny 对模糊后的图像进行边缘检测，生成一张二值化边缘图像。
位置搜索：在生成的边缘图像中，通过遍历像素值为 255（即边缘）的区域，找到砖块的中心位置。为了确保检测的准确性，还会屏蔽角色所在区域可能干扰到检测的部分。
砖块检测原理如图所示：

四、自动跳跃原理
自动跳跃的功能基于游戏角色与砖块之间的距离来模拟鼠标点击。以下是具体原理：
距离计算：使用欧几里得距离公式 distance = ((player_x - brick_x)**2 + (player_y - brick_y)**2)**0.5 计算游戏角色与砖块之间的距离。这里的 player_x 和 player_y 是角色的位置坐标，brick_x 和 brick_y 是砖块的位置坐标。
时间转换：根据距离计算合适的鼠标点击持续时间。通过公式 delay_time_s = distance / 530 将距离转换为时间，其中 530 是一个预设的比例因子，用于调整时间和距离之间的关系，确保跳跃的精准度和游戏中的实际表现相符。
鼠标模拟：使用 pyautogui.mouseDown 和 pyautogui.mouseUp 模拟鼠标按钮的按下和释放。通过设置合理的鼠标点击位置和持续时间，实现游戏角色的自动跳跃。
自动跳跃原理如图所示：

整个脚本的实现原理可以总结为以下流程：
通过鼠标标记位置确定游戏窗口截图的区域。
使用模板匹配技术检测游戏角色的位置。
应用边缘检测技术检测砖块的位置。
基于游戏角色与砖块的距离计算鼠标点击时间，模拟鼠标点击实现自动跳跃。
